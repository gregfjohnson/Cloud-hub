/* merge_cloud.c - cloud hub main program; link-level mesh networking
 *
 * Copyright (C) 2012, Greg Johnson
 * Released under the terms of the GNU GPL v2.0.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * $Id: merge_cloud.c,v 1.42 2012-02-22 19:27:23 greg Exp $
 */
static const char Version[] = "Version "
    "$Id: merge_cloud.c,v 1.42 2012-02-22 19:27:23 greg Exp $";

/* This is the main program in the cloud_hub project.  It creates and
 * maintains a link-level mesh network, and manages client traffic over
 * the mesh.
 *
 * command-line arguments:
 *      -a  /tmp/sig_strength:  file to save mac addresses and signal
 *          strengths we have detected from other boxes
 *
 *      -A:  run in ad-hoc mode versus WDS mode.  (found that works a LOT
 *          better.)
 *
 *      -b /tmp/eth_beacons:  file containing the mac addresses of other cloud
 *          boxes in our mesh that we notice via cat-5 LAN interface
 *
 *      -c N:  for debugging; process N messages and then exit
 *
 *      -d /tmp/beacons:  file containing the mac addresses of other cloud
 *          boxes in our mesh that we notice wirelessly
 *
 *      -D N:  toggle debug variable N
 *
 *      -e eth0:  the name of the cat-5 lan interface
 *
 *      -E nn:nn:nn:nn:nn:nn
 *          specify the mac address of the cat-5 lan interface.  if this is
 *          not given, use ifconfig to figure it out.
 *
 *      -f:  send ethernet beacon messages out on the cat-5 LAN interface,
 *           so that other boxes that can see me via cat-5 can join in my
 *           mesh, but communicating via "infinitely high signal strength"
 *           cat-5 connection
 *
 *      -i /tmp:  run in simulation mode, using pipes for communication to
 *          simulate wireless traffic.  this is old, probably broken, and
 *          would be worth getting working again at some point.
 *
 *      -l:  run an ll_shell_ftp service out of merge_cloud on the
 *           LAN cat-5 interface
 *
 *      -L /tmp/perm_log_file:
 *          name of permanent log file to write to under debugging control
 *          (if we want a long file rather than the short truncated file
 *          generated by "label" from our stdout/stderr)
 *
 *      -m prism0:  name of device to read for monitoring traffic to look
 *          for wireless beacons
 *
 *      -n:  don't read from stdin for interactive commands; run in batch mode
 *
 *      -N nn:nn:nn:nn:nn:nn
 *          specify mac address of client for link-level interactive debugging
 *
 *      -p /tmp/other_box_info:
 *          specify the file containing info about other boxes - their
 *          mac addresses, signal strength from them to us, etc.
 *          this is an input to merge_cloud.  the kernel or another
 *          program might generate it, or perhaps merge_cloud itself
 *          might generate it if the same file name is used here and with
 *          the "-a" argument above.
 *
 *      -P:  use a second interface (i.e., eth0:1) for mesh protocol messages,
 *           separate from the interface (i.e., eth0) used for client payload
 *           messages.  this is the default, and is a very good idea to always
 *           leave on.
 *
 *      -s /tmp/cloud_status:
 *          specify the file that mesh status is written to, so that
 *          the status_lights utility can read it and blink lights on the
 *          front of the box giving status information about the mesh
 *
 *      -T /tmp/temp_log:  
 *          name of temporary log file (we use this to send debug messages
 *          to the internet interface)
 *
 *      -w eth0:  the wireless interface (i.e., "wlan0" etc.)
 *
 *      -W nn:nn:nn:nn:nn:nn
 *          specify the mac address of the wireless interface
 *          (we figure it out on our own using ifconfig if this isn't given)
 *
 *      -y: detect signal strength by looking at wireless beacons
 *          (alternative is debugging mode where we look in signal 
 *          strength file and ignore wireless beacons)
 */

#include <sys/socket.h>
#include <sys/time.h>
#include <time.h>
#include <features.h>    /* for the glibc version number */
#include <asm/types.h>
#include <sys/types.h>
#include <linux/wireless.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>   /* The L2 protocols */
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <unistd.h>
#include <stdlib.h>
#include <math.h>
#include <netinet/in.h>
#include <ctype.h>

#include "cloud.h"
#include "mac.h"
#include "util.h"
#include "pio.h"
#include "wrt_util.h"
#include "eth_util.h"
#include "com_util.h"
#include "status.h"
#include "device_type.h"
#include "graphit.h"
#include "sequence.h"
#include "html_status.h"
#include "ping.h"
#include "cloud_mod.h"
#include "print.h"
#include "timer.h"
#include "random.h"
#include "io_stat.h"
#include "ad_hoc_client.h"
#include "lock.h"
#include "stp_beacon.h"
#include "device.h"
#include "nbr.h"
#include "scan_msg.h"
#include "parm_change.h"

#ifdef WRT54G
    #include "pcritical_section.h"
#else
    #include "critical_section.h"
#endif

/* debugging and configuration variables that can be changed at runtime
 * both locally and via messages across the entire cloud
 */
char_str_t db[] = {
    /*  0 */ {0, "add and delete devices"},
    /*  1 */ {0, "communication of non-cloud client messages"},
    /*  2 */ {0, "wait times"},
    /*  3 */ {0, "internal state (lock lists etc.)"},
    /*  4 */ {0, "terse, one-line message counts"},
    /*  5 */ {1, "permit local improvement"},
    /*  6 */ {0, "stp beacons (sending and receiving)"},
    /*  7 */ {0, "send_cloud_message pings"},
    /*  8 */ {0, "send_cloud_message print almost all messages"},
    /*  9 */ {0, "check_connectivity"},
    /* 10 */ {0, "local improvement debugging"},
    /* 11 */ {0, "check_local_improvement debugging"},
    /* 12 */ {0, "send_cloud_message print stp_beacon_msg's"},
    /* 13 */ {0, "bcast_forward_message non-cloud messages"},
    /* 14 */ {0, "recvfrom print"},
    /* 15 */ {0, "sendto print"},
    /* 16 */ {0, "pre_repeated_cloud_maint"},
    /* 17 */ {0, "check_nbr_devices"},
    /* 18 */ {0, "debug output to eth0"},
    /* 19 */ {0, "post_repeated_cloud_maint control flow"},
    /* 20 */ {0, "do_eth_beacon_no_send"},
    /* 21 */ {0, "connectivity when something happens"},
    /* 22 */ {0, "turn on flow control (always disabled by default; broken)"},
    /* 23 */ {0, "flow control debug"},
    /* 24 */ {0, "introduce dropped packet to test flow control"},
    /* 25 */ {0, "short print noncloud io stats"},
    /* 26 */ {0, "short print cloud io stats"},
    /* 27 */ {0, "suppress fprintf(stderr, ..)"},
    /* 28 */ {0, "alarm timeouts"},
    /* 29 */ {0, "debug drop an stp_beacon_recv_msg"},
    /* 30 */ {0, "send cloud status with stp beacons"},
    /* 31 */ {0, "build cloud stp list"},
    /* 32 */ {0, "debug cloud_stp_list"},
    /* 33 */ {0, "debug output to eth0 for interactive commands"},
    /* 34 */ {0, "main select"},
    /* 35 */ {0, "write to permanent log file"},
    /* 36 */ {1, "disable messages on the wlan device"},
    /* 37 */ {0, "overwrite log file"},
    /* 38 */ {0, "generate mesh topology display"},
    /* 39 */ {1, "slow down stp beacons based on number of boxes in cloud"},
    /* 40 */ {0, "multiplicative factor to slow down stp beacons to debug"},
    /* 41 */ {0, "print only 1 out of 20 error messages"},
    /* 42 */ {0, "dump all messages from cloud device"},
    /* 43 */ {0, "dump all messages from non-cloud devices"},
    /* 44 */ {0, "debug k-of-n message delivery"},
    /* 45 */ {0, "debug print beacon messages"},
    /* 46 */ {1, "enable ping neighbors"},
    /* 47 */ {1, "use secondary :1 devices for cloud messages"},
    /* 48 */ {0, "debug :1 accounting problem"},
    /* 49 */ {0, "wait_till_wont_block"},
    /* 50 */ {1, "ad-hoc passive client mode"},
    /* 51 */ {0, "debug ad_hoc_clients"},
    /* 52 */ {0, "debug ad-hoc passive client mode"},
    /* 53 */ {0, "debug input_available after select"},
    /* 54 */ {0, "make send_stp interrupts manual"},
    /* 55 */ {0, "clear permanent log file"},
    /* 56 */ {0, "debug ad-hoc client broadcast messages"},
    /* 57 */ {0, "emergency dump every message"},
    /* 58 */ {0, "wrt_util - print histogram of beacon inter-arrival times"},
    /* 59 */ {0, "wrt_util - debug wrt_util_process_message"},
    /* 60 */ {1, "non-local shortcuts for wrapped client messages"},
    /* 61 */ {0, "debug non-local shortcuts for wrapped client messages"},
    /* 62 */ {1, "enable wifi scanning"},
    /* 63 */ {0, "debug wifi scanning"},
    /* 64 */ {1, "debug global wifi paramater changing"},
    /* 65 */ {0, "don't really do global wifi paramater change for debugging"},
             {-1, NULL},
};

bool_t update_cloud_db = false;
int cloud_db_ind;

#define MAX_CLOUD 32

char *wds_file = "/proc/net/hostap/wlan0/wds";

char *eth_fname = "/usr/local/etc/wifi_cloud/eth_beacons";
char *wlan_fname = "/usr/local/etc/wifi_cloud/beacons";
char *sig_strength_fname = "/proc/net/hostap/wlan0/ap";
char *perm_log_fname = "/tmp/merge_cloud.perm_log";
char *temp_log_fname = "/tmp/merge_cloud.temp_log";

char *eth_device_name = 0;
char *wlan_device_name = "wlan0";

bool_t have_mon_device = false;
char *wlan_mon_device_name = NULL;
static int prism_fd = -1;

char use_pipes = 0;

char *pipe_directory = NULL;

static char stdin_input = 1;
static int msg_count = -1;

bool_t ad_hoc_mode = false;

/* use a separate interface such as eth0:1 etc. for cloud messages? */
static bool_t cloud_interface = true;

char do_wrt_beacon = 0;
static char do_eth_beacon = 0;
char do_ll_shell = 0;
char did_com_util_init = 0;
static mac_address_t com_util_mac_address = {0,0,0,0,0,0};

int wrapper_len = (int) (&((message_t *) 0)->v.msg.msg_body);
static byte *wrapper;

short my_weakest_stp_link = -1;
static short cloud_weak_link_boxes = -1;
static char *cloud_status_file = "/tmp/cloud_status";
static char cloud_status_tmp_file[PATH_MAX] = "/tmp/cloud_status.tmp";

int max_packet_len = 0;

static void cleanup(void);

/* this is my official name as a cloud box. */
mac_address_t my_wlan_mac_address;

/* did we get our wireless mac address from a command-line argument,
 * or do we need to figure it out?
 */
static char got_wlan_mac_addr = 0;

/* this is the optional mac address of my ethernet port.  it is good
 * iff eth_device_name is not null.
 */
mac_address_t my_eth_mac_address;
static char got_eth_mac_addr = 0;

#if 0
/* convenient debugging breakpoint function */
static void bp1(void)
{
    ddprintf("hi from bp1.\n");
}
#endif

/* I think this means we got called because of the arrival of a beacon,
 * and it is in the beacon variable below.
 */
bool_t have_beacon = false;
message_t beacon;

bool_t have_my_beacon = false;
message_t my_beacon;

/* these are our stp neighbors */
node_t stp_list[MAX_CLOUD];
int stp_list_count = 0;

/* do a complete print of the state of this cloud box.
 * print the locks we own, the locks we have granted to other boxes,
 * and the locks we have pending requests for to other boxes.
 *
 * print timed out locks.
 *
 * print the list of all nodes in our cloud.
 *
 * print the list of all of our neighbors, i.e., nodes we see 802.11 beacons
 * from or eth_beacons from (i.e., nodes we are attached to via cat-5 cable).
 */
void print_state()
{
    print_lockable_list(pending_requests, pending_request_count,
            "pending_requests");

    print_lockable_list(locks_granted, locks_granted_count,
            "locks_granted");

    print_lockable_list(locks_owned, locks_owned_count,
            "locks_owned");

    print_lockable_list(timed_out_lockables, timed_out_lockable_count,
            "timed out lockables");

    node_list_print(eprintf, stderr, "stp_list", stp_list, stp_list_count);

    print_cloud_list(nbr_device_list, nbr_device_list_count, "neighbor list:");

    ddprintf("my originator sequence number:  %d\n",
            (int) originator_sequence_num);

    print_stp_recv_beacons();
}

// #define DEBUG_48
#ifdef DEBUG_48
static message_t db_messages[MAX_CLOUD];
static int db_i[MAX_CLOUD];
static int db_dev_index[MAX_CLOUD];
#endif

/* this is an oh-sh*t type situation.  we abort all cloud protocol we were
 * in the middle of, and delete all stp beacons not from direct neighbors.
 */
void to_nominal_state()
{
    locks_owned_count = 0;
    locks_granted_count = 0;
    pending_request_count = 0;

    /* get rid of received beacons that came from stp neighbors we
     * no longer have.
     */
    trim_stp_recv_beacons(from_stp_neighbor);
}

/* this is for status_lights, the external indicator on the box of our
 * model of the whole cloud.
 */
static void update_cloud_status()
{
    int i, j;
    bool_t found;
    FILE *status;

    if (cloud_status_file == NULL) { return; }

    my_weakest_stp_link = 10000;
    for (i = 0; i < stp_list_count; i++) {

        found = false;
        for (j = 0; j < nbr_device_list_count; j++) {
            if (mac_equal(nbr_device_list[j].name, stp_list[i].box.name)) {
                found = true;
                break;
            }
        }

        if (found) {
            if (my_weakest_stp_link > nbr_device_list[j].signal_strength) {
                my_weakest_stp_link = nbr_device_list[j].signal_strength;
            }
        }
    }

    if (my_weakest_stp_link == 10000) {
        my_weakest_stp_link = -1;
    }

    cloud_weak_link_boxes = 0;

    if (my_weakest_stp_link != -1 && my_weakest_stp_link < weak_threshold) {
        cloud_weak_link_boxes++;
    }

    for (i = 0; i < stp_recv_beacon_count; i++) {
        if (stp_recv_beacons[i].stp_beacon.weakest_stp_link < weak_threshold
            && stp_recv_beacons[i].stp_beacon.weakest_stp_link != -1)
        {
            cloud_weak_link_boxes++;
        }
    }

    status = fopen(cloud_status_tmp_file, "w");
    if (status == NULL) {
        ddprintf("update_cloud_status; unable to open %s:  %s\n",
                cloud_status_tmp_file, strerror(errno));
        return;
    }
    fprintf(status, "%4d    # cloud box count\n", stp_recv_beacon_count + 1);
    fprintf(status, "%4d    # my weakest stp link\n", my_weakest_stp_link);
    fprintf(status, "%4d    # cloud weak link count\n", cloud_weak_link_boxes);
    fclose(status);

    if (rename(cloud_status_tmp_file, cloud_status_file) != 0) {
        ddprintf("update_cloud_status; unable to rename %s to %s:  %s\n",
                cloud_status_tmp_file, cloud_status_file, strerror(errno));
    }

} /* update_cloud_status */

/* do initial periodic processing after an internally generated timing
 * interrupt if the interrupt was a send_stp or a lockable_timeout.
 * we check to see if there are any new cloud boxes or clients we didn't
 * already know about, and update our idea of our own cloud box neighbors.
 * we update our idea of signal strength to our neighbors, i.e., the cloud
 * boxes we can see directly.
 *
 * this routine is called before processing any incoming messages that
 * may be available to be read and processed.
 */
static bool_t pre_repeated_cloud_maint()
{
    bool_t result;
    bool_t nbr_connectivity_changed;

    if (db[16].d) { ddprintf("pre_repeated_cloud_maint..\n"); }

    result = check_devices();
    if (db[16].d) { ddprintf("    changed %d..\n", result); }

    nbr_connectivity_changed = check_nbr_devices();
    result |= nbr_connectivity_changed;

    if (nbr_connectivity_changed) { update_stp_nbr_connectivity(); }

    update_nbr_signal_strength();

    if (db[16].d) { ddprintf("    changed %d..\n", result); }
    return result;
}

/* do final periodic processing after an internally generated timing
 * interrupt if the interrupt was a send_stp or a lockable_timeout.
 * this routine is called after pending incoming messages have been
 * processed.  we check the cloud topology and decide based on measured
 * signal strengths to neighbors whether we want to initiate a cloud
 * topology change.  we send out an stp beacon.
 */
static void post_repeated_cloud_maint()
{
    if (db[3].d) { ddprintf("post_repeated_cloud_maint..\n"); }
    timeout_lockables();
    check_connectivity();
    send_stp_beacon(false /* no disconnected nbr */);
    if (db[5].d) {
        check_local_improvement();
    }
    if (db[50].d) {
        check_ad_hoc_client_improvement();
    }
} /* post_repeated_cloud_maint */

static void catch_hup(int arg)
{
    ddprintf("caught a hup..\n");
}

static void catch_int(int arg)
{
    ddprintf("caught an int..\n");
}

/* for debugging; after "msg_count" messages, exit. */
void check_msg_count()
{
    if (msg_count != -1) {
        if (--msg_count <= 0) {
            cleanup();
            exit(0);
        }
        ddprintf("%d:  ", msg_count);
    }
}

static void reset_state(void)
{
    pending_request_count = 0;
    locks_granted_count = 0;
    locks_owned_count = 0;
    timed_out_lockable_count = 0;
    stp_recv_beacon_count = 0;
    stp_list_count = 0;
    io_stat_count = 0;
}

/* delete pending requests, locks granted, and locks owned to this node,
 * and delete them from our stp_list.  circularity has been detected.
 * after clearing everything, we will probably try to rebuild, but that's
 * not the job of this routine.
 */
void clear_state(mac_address_ptr_t name)
{
    delete_lockable(pending_requests, &pending_request_count, name);
    delete_lockable(locks_granted, &locks_granted_count, name);
    delete_lockable(locks_owned, &locks_owned_count, name);

    delete_me = name;
    trim_list(stp_list, &stp_list_count, delete_node, NULL);

    delete_stp_beacon(name);
}

static void usage()
{
    ddprintf("usage:\ncloud [-e ethN] \\\n"
            "    [-E eth-mac-address] \\\n"
            "    [-W wlan-mac-address]\n"
            "    [-w wlanN] \\\n"
            "    [-p wds_file] \\\n"
            "    [-a sig_strength_file] \\\n"
            "    [-b eth_beacon_file] \\\n"
            "    [-d wireless_beacon_file] \\\n"
            "    [-c message_count] \\\n"
            "    [-D debug_index] \\\n"
            "    [-n] \\\n"
            "    [-i pipe_directory]\n");
    exit(1);
}

static void process_args(int argc, char **argv)
{
    int c;
    int i;

    ddprintf("args:  ");
    for (i = 0; i < argc; i++) {
        ddprintf("%s ", argv[i]);
    }
    ddprintf("\n");

    while ((c = getopt(argc, argv, "Alfm:yc:np:a:w:W:b:d:e:E:D:i:N:s:L:P"))
        != -1)
    {
        switch (c) {

        case 'a' :
            sig_strength_fname = strdup(optarg);
            break;

        case 'A' :
            ad_hoc_mode = true;
            break;

        case 'b' :
            eth_fname = strdup(optarg);
            break;

        case 'c' : {
            int result = sscanf(optarg, "%d", &msg_count);
            if (result != 1) {
                ddprintf("invalid message count '%s'\n", optarg);
                exit(1);
            }
            break;
        }

        case 'd' :
            wlan_fname = strdup(optarg);
            break;

        case 'D' :
            tweak_db(optarg, db);
            break;

        case 'e' :
            eth_device_name = strdup(optarg);
            break;

        case 'E' :
            if (1 != mac_sscanf(my_eth_mac_address, optarg)) {
                ddprintf("invalid eth mac address '%s'\n", optarg);
                exit(1);
            }
            got_eth_mac_addr = 1;
            break;

        case 'f' :
            do_eth_beacon = 1;
            break;

        case 'i' :
            use_pipes = 1;
            pipe_directory = strdup(optarg);
            break;

        case 'l' :
            do_ll_shell = 1;
            break;

        case 'L' :
            perm_log_fname = strdup(optarg);
            break;

        case 'm' :
            have_mon_device = true;
            wlan_mon_device_name = strdup(optarg);
            break;

        case 'n' :
            stdin_input = 0;
            break;

        case 'N' :
            if (1 != mac_sscanf(com_util_mac_address, optarg)) {
                ddprintf("invalid com_util mac address '%s'\n", optarg);
                exit(1);
            }
            break;

        case 'p' :
            wds_file = strdup(optarg);
            break;

        case 'P' :
            cloud_interface = true;
            db[47].d = true;
            break;

        case 's' :
            cloud_status_file = strdup(optarg);
            strncpy(cloud_status_tmp_file, cloud_status_file, PATH_MAX);
            break;

        case 'T' :
            temp_log_fname = strdup(optarg);
            break;

        case 'w' :
            wlan_device_name = strdup(optarg);
            break;

        case 'W' :
            if (1 != mac_sscanf(my_wlan_mac_address, optarg)) {
                ddprintf("invalid wlan mac address '%s'\n", optarg);
                exit(1);
            }
            got_wlan_mac_addr = 1;
            break;

        case 'y' :
            do_wrt_beacon = 1;
            break;

        default :
            usage();
        }
    }
}

#if 0
/* debug-print bits of a select() result */
static void db_print_read_set(char *title, int result, fd_set *read_set,
        int max_fd)
{
    int i;
    ddprintf("%s; select returned %d:  ", title, result);
    for (i = 0; i < max_fd + 1; i++) {
        if (FD_ISSET(i, read_set)) {
            ddprintf("%d ", i);
        }
    }
    ddprintf("\n");
}
#endif

/* do a non-blocking test to see if fd can be read without blocking */
static bool_t read_wont_block(int fd)
{
    static struct timeval timer = { 0, 0 };
    fd_set read_set;
    int result;

    FD_ZERO(&read_set);
    FD_SET(fd, &read_set);

    result = select(fd + 1, &read_set, 0, 0, &timer);

    return (FD_ISSET(fd, &read_set));
}

static void cleanup()
{
    #ifdef WRT54G
        pcritical_section_delete();
    #else
        critical_section_delete();
    #endif

    if (do_ll_shell) {
        com_util_exit();
    }
}

int main(int argc, char **argv)
{
    struct sockaddr_ll recv_arg;
    socklen_t recv_arg_len;
    int result;
    int input_available;
    int got_input;
    char buf[256];
    int i;
    bool_t fake_interrupt = false;

    /* avoid compiler warnings */
    (void) mac_buf1; (void) mac_buf2; (void) mac_buf3;

    while (!checked_gettimeofday(&now));
    start = now;

    /* pretend that each timed function last occurred at program start */
    times[0] = now;
    times[1] = now;
    times[2] = now;

    process_args(argc, argv);

    #ifdef WRT54G
        pcritical_section_init();
    #else
        critical_section_init();
    #endif

    /* if we are in ad-hoc mode, disable messsages to wireless ap clients */
    if (ad_hoc_mode) { db[36].d = true; }

    /* for now, just always disable flow control. */
    db[22].d = false;

    while (true) {
        wrapper = malloc(wrapper_len);
        if (wrapper == NULL) {
            ddprintf("give me a break.  the malloc for wrapper didn't work.\n");
        } else {
            break;
        }
    }

    for (i = 0; i < MAX_CLOUD; i++) {
        send_sequence[i] = 0;
        send_data_sequence[i] = 0;
        send_ping_sequence[i] = 0;

        have_recv_sequence[i] = false;
        have_recv_data_sequence[i] = false;
        have_recv_ping_sequence[i] = false;
    }

    improve_prob_init(stp_recv_beacon_count);

    if (!got_wlan_mac_addr) {
        mac_get(my_wlan_mac_address, wlan_device_name);
    }

    init_cloud_stp_tree();

    /* adding wlan0:1 first hopefully means that if there are available
     * messages both on it and wlan0, wlan0:1 will get processed first.
     * (would like to process 'ignore ad-hoc client bcast messages' messages
     * before ad-hoc client bcast messages.)
     */
    if (db[47].d && ad_hoc_mode) {
        sprintf(buf, "%s:1", wlan_device_name);
        add_device(buf, my_wlan_mac_address, device_type_cloud_wlan);
    }

    add_device(wlan_device_name, my_wlan_mac_address, device_type_wlan);
    status_add_by_mac(perm_io_stat, &perm_io_stat_count, my_wlan_mac_address,
            device_type_wlan);
    if (db[50].d) {
        promiscuous(wlan_device_name, true);
    }

    if (eth_device_name != 0) {
        if (!got_eth_mac_addr) {
            mac_get(my_eth_mac_address, eth_device_name);
        }

        /* for consistency with above; process ethN:1 messages before ethN
         * messages.
         */
        if (db[47].d) {
            sprintf(buf, "%s:1", eth_device_name);
            add_device(buf, my_eth_mac_address, device_type_cloud_eth);
        }

        add_device(eth_device_name, my_eth_mac_address, device_type_eth);
        status_add_by_mac(perm_io_stat, &perm_io_stat_count, my_eth_mac_address,
                device_type_eth);
        promiscuous(eth_device_name, true);
    }

    if (have_mon_device) {
        add_device(wlan_mon_device_name, my_wlan_mac_address,
                device_type_wlan_mon);
        prism_fd = device_list[device_list_count - 1].fd;
        ddprintf("prism fd:  %d\n", prism_fd);
    }

    init_random(my_wlan_mac_address);

    timer_init();

    if (do_eth_beacon || do_ll_shell || do_wrt_beacon) {
        int i;
        char did_eth_beacon = 0, did_wrt_beacon = 0;

        for (i = 0; i < device_list_count; i++) {

            if (do_eth_beacon
                && device_list[i].device_type == device_type_eth
                && !did_eth_beacon)
            {
                did_eth_beacon = 1;

                eth_util_init(eth_fname, device_list[i].fd,
                        device_list[i].if_index,
                        use_pipes ? &device_list[i].out_pio : 0,
                        my_eth_mac_address,
                        my_wlan_mac_address);
            }

            if (do_ll_shell
                && device_list[i].device_type == device_type_wlan
                && !did_com_util_init)
            {
                did_com_util_init = 1;

                com_util_init(device_list[i].fd, device_list[i].if_index,
                        use_pipes ? &device_list[i].out_pio : 0,
                        my_wlan_mac_address, com_util_mac_address);
            }

            if (do_wrt_beacon
                && device_list[i].device_type == device_type_wlan
                && !did_wrt_beacon)
            {
                did_wrt_beacon = 1;
                wrt_util_init(wlan_fname, sig_strength_fname);
            }
        }

        if (do_eth_beacon && !did_eth_beacon) {
            ddprintf("did not find eth device for eth_util_init\n");
            exit(1);
        }

        if (do_ll_shell && !did_com_util_init) {
            ddprintf("did not find eth device for com_util_init\n");
            exit(1);
        }

        if (do_wrt_beacon && !did_wrt_beacon) {
            ddprintf("did not find wrt device for wrt_util_init\n");
            exit(1);
        }
    }

    if (do_ll_shell) {
        if (com_util_start_shell() != 0) {
            ddprintf("com_util_start_shell failed\n");
            exit(1);
        }
    }

    check_devices();
    check_nbr_devices();
    update_nbr_signal_strength();

    #if USE_TIMER
    {
        struct sigaction action;

        memset(&action, 0, sizeof(action));
        action.sa_handler = repeated;

        sigaction(SIGALRM, &action, NULL);

        set_next_alarm();

        memset(&action, 0, sizeof(action));
        action.sa_handler = catch_hup;

        sigaction(SIGHUP, &action, NULL);

        memset(&action, 0, sizeof(action));
        action.sa_handler = catch_int;

        sigaction(SIGINT, &action, NULL);
    }
    #else
        /* for gdb-based debugging */
        // signal(SIGINT, &repeated);
    #endif

    while (1) {
        int max_fd = -1;
        int dev, dev_index;
        fd_set read_set;
        int select_result;

        /* set up the read_set for the select */
        FD_ZERO(&read_set);

        /* get input from a pio? rejuvenate this code eventually. */
        input_available = 0;
        if (use_pipes) {
            int i;
            for (i = 0; i < device_list_count; i++) {
                if (ack_read_ok(i) && pio_read_ok(&device_list[i].in_pio)) {
                    input_available = 1;
                    break;
                }
            }
        }

        /* do a select to see which interface has input available.
         * we do the wds interfaces, the wireless interfaces, and the ethernet
         * interface.  if we are doing flow control, and are waiting for
         * an ack from one or more downstream devices, only read input from 
         * the devices that may give us the ack's we are waiting for.
         */
        if (!input_available) {
            int i;

            for (i = 0; i < device_list_count; i++) {
                if (ack_read_ok(i)) {
                    if (db[47].d
                        || (device_list[i].device_type != device_type_cloud_wlan
                        && device_list[i].device_type != device_type_cloud_eth))
                    {
                        FD_SET(device_list[i].fd, &read_set);
                        if (device_list[i].fd > max_fd) {
                            max_fd = device_list[i].fd;
                        }
                    }
                }
            }

            FD_SET(interrupt_pipe[0], &read_set);
            if (interrupt_pipe[0] > max_fd) { max_fd = interrupt_pipe[0]; }

            if (stdin_input) { FD_SET(0, &read_set); }

            if (do_ll_shell) {
                com_util_set_select(&max_fd, &read_set);
            }

            select_result = select(max_fd + 1, &read_set, 0, 0, 0);

            if (select_result == -1) {
                if (errno != EINTR) {
                    ddprintf("main; select failed:  %s\n", strerror(errno));
                }
                continue;

            }
            
            if (db[53].d) {
                bool_t prt = false;
                for (i = 0; i < device_list_count; i++) {
                    if (FD_ISSET(device_list[i].fd, &read_set)
                        && device_list[i].device_type != device_type_wlan_mon)
                    {
                        if (!prt) {
                            ddprintf("input is available; ");
                            prt = true;
                        }
                        ddprintf("%d ", i);
                    }
                }
                if (prt) { ddprintf("\n"); }
            }
        }

        fake_interrupt = false;

        #ifdef WRT54G
            pcritical_section_enter();
        #else
            critical_section_enter();
        #endif

        /* if the interrupt level redid file descriptors,
         * clear the pipe and go back to the select on the
         * new file descriptors
         */
        if (FD_ISSET(interrupt_pipe[0], &read_set)) {
            char changed;

            read_all_available(interrupt_pipe[0]);

            if (got_interrupt[process_beacon] && do_wrt_beacon) {
                got_interrupt[process_beacon] = 0;
                wrt_util_interrupt();
            }

            if (got_interrupt[process_eth_beacon]) {
                got_interrupt[process_eth_beacon] = 0;

                if (do_eth_beacon) {
                    if (db[20].d) {
                        eth_util_interrupt_no_send();
                    } else {
                        eth_util_interrupt();
                    }
                }
            }

            /* if we are doing flow control, which only happens for
             * non-cloud packets being passed around wirelessly inside the
             * cloud, we use timeouts to decide when to resend the packet.
             * (i.e., if we haven't received an ack we need.)
             */
            if (got_interrupt[noncloud_message]) {
                if (db[23].d) { ddprintf("got packet timeout; resending..\n"); }
                got_interrupt[noncloud_message] = 0;
                resend_packets();
            }

            if (got_interrupt[send_stp] || got_interrupt[lockable_timeout]) {

                changed = pre_repeated_cloud_maint();

                if (changed) {
                    if (db[19].d) {
                        ddprintf("pre_repeated_cloud_maint change.\n");
                    }
                    #if 0
                    got_interrupt[send_stp] = 0;
                    if (got_interrupt[lockable_timeout]) {
                        ddprintf("pre got int[lockable_timeout]; changed; "
                                "clearing..\n");
                    }
                    got_interrupt[lockable_timeout] = 0;
                    goto done;
                    #endif
                }
                if (db[19].d) {
                    ddprintf("pre_repeated_cloud_maint no change.\n");
                }
            }
        }

        /* got_input is true iff we get something from stdin (a debugging
         * command) or we get something from /tmp/cloud.db, a back door for
         * stdin when we want to run in background and can't read from stdin.
         */
        got_input = 0;
        {
            FILE *f = fopen("/tmp/cloud.db", "r");
            if (f != NULL) {
                char *p = fgets(buf, 32, f);
                if (p == NULL) {
                    // ddprintf("cloud.db read error\n");
                } else {
                    ddprintf("debug read result %s\n", buf);
                    result = unlink("/tmp/cloud.db");
                    if (result == -1) {
                        ddprintf("ick.  couldn't unlink /tmp/cloud.db:  "
                                "%s\n", strerror(errno));
                    }
                    got_input = 1;
                }
                fclose(f);
            }
        }

        if (!got_input && FD_ISSET(0, &read_set)) {
            int i;
            int result;
            block_timer_interrupts(SIG_BLOCK);
            result = read(0, buf, 256);
            block_timer_interrupts(SIG_UNBLOCK);
            if (result <= 0) {
                ddprintf("error reading stdin:  %s\n", strerror(errno));
                goto done;
            }
            buf[255] = '\0';
            for (i = 0; i < 255; i++) {
                if (buf[i] == '\n') {
                    buf[i + 1] = '\0';
                    break;
                }
            }
            got_input = 1;
        }

        if (got_input) {
            char c = buf[0];
            if (db[33].d) { eth_print_cmd = true; }
            if (db[37].d) {
                com_util_get_server_pid("/tmp/ll_shell_ftp.pid");
                temp_log_file = com_util_open_temp_file(temp_log_fname);
                temp_print_cmd = true;
            }
            switch (c) {

            case 'a' :
                test_devices();
                goto done;

            case 'A' :
                print_ad_hoc_clients();
                goto done;

            case 'b' : {
                wrt_util_print_beacons();
                goto done;
            }

            case 'C' :
                start_parm_change("/tmp/parm_change");
                goto done;

            case 'c' :
                print_io_stats(eprintf, stderr);
                goto done;

            case 'd' : {
                int i;
                tweak_db_vec(&buf[1], db);
                for (i = 0; i < UTIL_DB_VEC_MAX; i++) {
                    ddprintf("db loop i:  %d\n", i);
                    if (util_db_vec[i] == -1) { break; }
                    ddprintf("db loop vec[i]:  %d\n", (int) util_db_vec[i]);

                    if (util_db_vec[i] == 46 && db[46].d) {
                        do_ping_neighbors();

                    } else if (util_db_vec[i] == 38) {
                        restart_disable_print_cloud();

                    } else if (util_db_vec[i] == 50) {
                        ddprintf("set promiscuous %s\n",
                                db[50].d ? "on" : "off");
                        promiscuous(wlan_device_name, db[50].d);

                    } else if (util_db_vec[i] == 58) {
                        wrt_util_set_debug(0, !wrt_util_get_debug(0));

                    } else if (util_db_vec[i] == 59) {
                        wrt_util_set_debug(1, !wrt_util_get_debug(1));
                    }
                }
                goto done;
            }

            /* change the local debug variable, and send that value out
             * to all other cloud boxes.
             */
            case 'D' : {
                int db_ind;
                if (update_cloud_db) {
                    ddprintf("update_cloud_db already pending\n");
                } else {
                    db_ind = tweak_db(&buf[1], db);
                    if (db_ind != -1 && stp_recv_beacon_count > 0) {
                        update_cloud_db = true;
                        cloud_db_ind = db_ind;
                        if (db[db_ind].d) {
                            cloud_db_ind += 2000;
                        } else {
                            cloud_db_ind += 1000;
                        }
                        ddprintf("cloud_db_ind:  %d\n", cloud_db_ind);
                    }
                }
                goto done;
            }

            case 'h' : {
                int i;

                for (i = 0; db[i].d != -1; i++) {
                    ddprintf("%2d:  %d; %s\n", i, db[i].d, db[i].str);
                }
                
                goto done;
            }

            case 'i' : {
                got_interrupt[send_stp] = 1;
                fake_interrupt = true;
                send_interrupt_pipe_char();

                goto done;
            }

            case 'I' :
                ddprintf("status_dprint_short_array:\n");
                status_dprint_short_array(eprintf, stderr, perm_io_stat,
                        perm_io_stat_count);
                goto done;

            case 'j' :
                ddprintf("db_print_cloud_stp_list:\n");
                db_print_cloud_stp_list(eprintf, stderr);

                ddprintf("\ndprint_cloud_stats_short:\n");
                dprint_cloud_stats_short(eprintf, stderr);

                ddprintf("\n");
                graphit_dprint(eprintf, stderr, &cloud_stp_tree[0]);

                goto done;

            case 'J' :
                dprint_cloud_stats(eprintf, stderr);
                goto done;

            case 'l' :
                force_local_change = 1;
                old_db5 = db[5].d;
                db[5].d = 1;
                break;

            case 'o' :
                ddprintf("send_ping..\n");
                send_ping(&buf[1]);
                goto done;

            case 'p' :
                print_state();
                print_devices();
                print_ad_hoc_clients();
                // print_io_stats(eprintf, stderr);
                goto done;

            case 'P' :
                ddprintf("send_nbr_pings..\n");
                send_nbr_pings();
                goto done;

            case 'q' :
                cleanup();
                exit(0);

            case 'r' :
                reset_io_stats();
                goto done;

            case 'R' :
                reset_state();
                goto done;

            case 's' :
                send_stp_beacon(false /* no disconnected nbr */);
                goto done;

            case 'S' :
                stp_list_count = 0;
                stp_recv_beacon_count = 0;
                reset_state();
                goto done;

            case 't' :
                timeout_locks();
                goto done;

            case 'T' : {
                struct itimerval timer;
                int result = getitimer(ITIMER_REAL, &timer);
                if (result == -1) {
                    ddprintf("getitimer failed:  %s\n", strerror(errno));
                }
                ddprintf("time to go:  <%ld %ld>; reset value:  <%ld %ld>\n",
                        timer.it_value.tv_sec, timer.it_value.tv_usec,
                        timer.it_interval.tv_sec, timer.it_interval.tv_usec);

                timer_print();

                goto done;
            }

            case 'w' :
                ddprintf("calling scan_timer..\n");
                scan_timer();

                goto done;

            case 'z' : {
                int i, j;
                for (i = 0; i < device_list_count; i++) {
                    for (j = 0; j < ad_hoc_client_count; j++) {
                        if (mac_equal(ad_hoc_clients[j].client,
                            device_list[i].mac_address))
                        {
                            mac_copy(device_list[i].mac_address,
                                    mac_address_zero);
                            /* just to make sure we don't match a bcast dest */
                            device_list[i].mac_address[5] = 0xff;
                        }
                    }
                }
                ad_hoc_client_count = 0;
                goto done;
            }


            default :
                // ddprintf("got char '%c' from stdin\n", c);
                goto done;
            }
        }
        eth_print_cmd = false;
        temp_print_cmd = false;
        com_util_close_temp_file(temp_log_fname, &temp_log_file);

        if (do_ll_shell) {
            com_util_shell_input(&read_set);
        }

        if (got_interrupt[send_stp] || got_interrupt[lockable_timeout]) {
            if (db[3].d) { print_stp_recv_beacons(); }
        }

        input_available = 0;
        for (i = 0; i < device_list_count; i++) {
            if ((use_pipes && pio_read_ok(&device_list[i].in_pio))
                || (!use_pipes && FD_ISSET(device_list[i].fd, &read_set)))
            {
                input_available = 1;
                break;
            }
        }

        if (input_available) {

            for (dev_index = 0; dev_index < device_list_count; dev_index++) {
                message_t raw_message;
                message_t *msg_buffer =
                        (message_t *) &raw_message.v.msg.msg_body;

                message_t *message;
                message_t *msg_body;

                /* is_298x_msg true => h_proto field indicates 298x message
                 * is_298x_msg false => not a 298x message
                 */
                bool_t is_298x_msg;

                /* is this a client packet we are supposed to forward to
                 * other cloud boxes in the spanning tree?
                 */
                int msg_type;
                bool_t accept;
                bool_t oops;
                bool_t forward_packet;

                /* if we are waiting for an ack from a payload message we
                 * sent to another cloud box, don't read from any input device
                 * except ones we are waiting for acks from.
                 *
                 * ad-hoc pseudo-devices come after wlan device in the
                 * device_list.  we will have read the wlan device already,
                 * so don't try to read the ad-hoc device's fd, which is really
                 * just the wlan device's fd.
                 */
                if (((use_pipes && !pio_read_ok(&device_list[dev_index].in_pio))
                    || (!use_pipes && !FD_ISSET(device_list[dev_index].fd,
                    &read_set)))
                    || (ad_hoc_mode && device_list[dev_index].device_type
                        == device_type_ad_hoc))
                {
                    continue;
                }

                if (db[34].d) {
                    ddprintf("reading dev_index %d, fd %d\n",
                            dev_index, device_list[dev_index].fd);
                }

                check_msg_count();

                if (use_pipes) {
                    result = pio_read(&device_list[dev_index].in_pio,
                            (void *) &msg_buffer,
                            sizeof(msg_buffer));
                    if (db[14].d && is_wlan(&device_list[dev_index])) {
                        pio_print(stderr, &device_list[dev_index].in_pio);
                    }
                } else {
                    memset(&recv_arg, 0, sizeof(recv_arg));
                    recv_arg.sll_family = AF_PACKET;
                    recv_arg.sll_ifindex = device_list[dev_index].if_index;
                    recv_arg.sll_protocol = htons(ETH_P_ALL);

                    /* alternative read scheme- read every message into
                     * msg_body, then look at message and decide if
                     * it's a 298x message or not.
                     *
                     * if not, point msg_body * at what was read, and
                     * message at start of (unread) 298x message header.
                     *
                     * if so, point message at start of what was actually read.
                     *
                     * if we are reading from the cloud, read it into the
                     * wrapped message, assuming a header has been put on it.
                     *
                     * we can receive unwrapped client packets or 2983
                     * packets from eth.
                     *
                     * if we are in wds mode, we can only receive unwrapped
                     * client packets from wlan.
                     *
                     * we can only receive 2983 or 2986 from wds interfaces or
                     * the wlan interface if we are in ad-hoc mode.
                     * (until we allow ad-hoc clients, but that's another
                     * story.)
                     *
                     * we receive beacon messages in via prism0.  (and possibly
                     * lots of other garbage.  may be worth it to limit the
                     * length of reads on prism0 to save on shlepping of bits.)
                     * (but, at some point we might want to try to be clever
                     * and use prism0 to overhear wds messages, to do nonlocal
                     * propagation in wds mode.)
                     */

                    if (read_wont_block(device_list[dev_index].fd)) {

                        block_timer_interrupts(SIG_BLOCK);

                        result = recvfrom(device_list[dev_index].fd,
                                (void *) msg_buffer,
                                sizeof(*msg_buffer), 0,
                                (struct sockaddr *) &recv_arg,
                                &recv_arg_len);

                        block_timer_interrupts(SIG_UNBLOCK);

                    } else {
                        ddprintf("read would block.\n");
                        continue;
                    }
                }

                /* if the recvfrom produced an error, report it and try
                 * the next device
                 */
                if (result == -1) {
                    ddprintf("recvfrom error:  %s\n", strerror(errno));
                    io_stat[device_list[dev_index].stat_index].recv_error++;
                            
                    continue;
                }

                if (db[57].d) {
                    ddprintf("from device %d:\n", dev_index);
                    fn_print_message(eprintf, stderr,
                            (unsigned char *) msg_buffer,
                            (result > 158) ? 158 : result);
                }

                /* is this a 298x message?
                 * if so, "message" (pointer to message with header we can
                 * use when sending is the actual message we just received,
                 * and "msg_body" (wrapped message from outside the cloud)
                 * is inside what we just received.
                 *
                 * if not, we just received a message from outside the
                 * cloud, which we will wrap if we need to pass it along
                 * inside the cloud.  "msg_body" is what we just received.
                 * (the receive buffer is actually a field inside a larger
                 * struct "raw_mesage".)  "message" is a pointer to the
                 * beginning of that
                 * larger struct, and we will use the beginning of that
                 * struct as our wrapper when sending the message out to other
                 * cloud boxes.
                 */
                if (msg_buffer->eth_header.h_proto >= htons(CLOUD_MSG)
                    && msg_buffer->eth_header.h_proto
                        <= htons(WRAPPED_CLIENT_MSG))
                {
                    message = msg_buffer;
                    msg_body = (message_t *)
                            msg_buffer->v.msg.msg_body;
                    is_298x_msg = true;
                } else {
                    message = &raw_message;
                    msg_body = (message_t *) msg_buffer;
                    is_298x_msg = false;

                    result += wrapper_len;
                }

                if (is_298x_msg) {
                    if (message->message_type == ad_hoc_bcast_block_msg
                        || message->message_type == ad_hoc_bcast_unblock_msg)
                    {
                        msg_type = AD_HOC_BLOCK_MSG;
                    } else {
                        msg_type = ntohs(message->eth_header.h_proto);
                    }

                } else if (wrt_util_beacon_message((byte *) msg_body,
                        result - wrapper_len))
                {
                    msg_type = PRISM_MSG;
                } else {
                    msg_type = OTHER_MSG;
                }

                /* if this is an incoming message from a wireless
                 * ad-hoc client, ignore it unless it's coming from a client
                 * that we own.
                 */
                if (db[50].d
                    && !is_298x_msg
                    && (device_list[dev_index].device_type == device_type_wlan
                        || device_list[dev_index].device_type
                            == device_type_cloud_wlan)
                    /* why don't we consider ignoring these guys? */
                    /*
                    && !mac_equal(msg_buffer->eth_header.h_dest,
                        mac_address_zero)
                    && !mac_equal(msg_buffer->eth_header.h_dest,
                        mac_address_bcast) */)
                {
                    int i;
                    bool_t skip_it = true;
                    if (db[52].d) { ddprintf("skip message?\n"); }
                    for (i = 0; i < ad_hoc_client_count; i++) {
                        if (mac_equal(msg_buffer->eth_header.h_source,
                                ad_hoc_clients[i].client)
                            && ad_hoc_clients[i].my_client
                                == AD_HOC_CLIENT_MINE)
                        {
                            skip_it = false;
                            break;
                        }
                    }
                    if (skip_it) {
                        if (db[52].d) { ddprintf("yes.\n"); }
                        continue;
                    }

                    if (db[52].d) {
                        int len = result - wrapper_len;
                        ddprintf("got a message in from an ad-hoc client:\n");
                        fn_print_message(eprintf, stderr,
                                (unsigned char *) msg_buffer,
                                (len > 100) ? 100 : len);
                    }
                }

                /* if we are doing ad-hoc clients
                 * we are in promiscuous mode, so we will hear cloud messages
                 * not meant for us.  if this is a cloud message not meant
                 * for us, ignore it.
                 */
                if (db[50].d
                    && (device_list[dev_index].device_type == device_type_wlan
                        || device_list[dev_index].device_type
                            == device_type_cloud_wlan)
                    && is_298x_msg
                    && !mac_equal(message->eth_header.h_dest,
                        my_wlan_mac_address)
                    && !mac_equal(message->eth_header.h_dest,
                        mac_address_zero)
                    && !mac_equal(message->eth_header.h_dest,
                        mac_address_bcast))
                { continue; }

                if (ad_hoc_mode && db[47].d) {
                oops = false;
                switch (msg_type) {

                    case CLOUD_MSG :
                    switch (device_list[dev_index].device_type) {
                        case device_type_wlan :       accept = false; break;
                        case device_type_cloud_wlan : accept = true;  break;
                        case device_type_wlan_mon :   accept = false; break;
                        case device_type_eth :        accept = false; break;
                        case device_type_cloud_eth :  accept = true;  break;
                        default :                     oops   = true;  break;
                    }
                    break;

                    case ETH_BCN_MSG :
                    switch (device_list[dev_index].device_type) {
                        case device_type_wlan :       accept = false; break;
                        case device_type_cloud_wlan : accept = false; break;
                        case device_type_wlan_mon :   accept = false; break;
                        case device_type_eth :        accept = true;  break;
                        case device_type_cloud_eth :  accept = false; break;
                        default :                     oops   = true;  break;
                    }
                    break;

                    case LL_SHELL_MSG :
                    switch (device_list[dev_index].device_type) {
                        case device_type_wlan :       accept = true;  break;
                        case device_type_cloud_wlan : accept = false; break;
                        case device_type_wlan_mon :   accept = false; break;
                        case device_type_eth :        accept = true;  break;
                        case device_type_cloud_eth :  accept = false; break;
                        default :                     oops   = true;  break;
                    }
                    break;

                    /* use the normal interface for all client communication;
                     * reserve :1 interface for just cloud messages.
                     */
                    case WRAPPED_CLIENT_MSG :
                    switch (device_list[dev_index].device_type) {
                        case device_type_wlan :       accept = true;  break;
                        case device_type_cloud_wlan : accept = false; break;
                        case device_type_wlan_mon :   accept = false; break;
                        case device_type_eth :        accept = true;  break;
                        case device_type_cloud_eth :  accept = false; break;
                        default :                     oops   = true;  break;
                    }
                    break;

                    case AD_HOC_BLOCK_MSG :
                    case OTHER_MSG :
                    switch (device_list[dev_index].device_type) {
                        case device_type_wlan :       accept = true;  break;
                        case device_type_cloud_wlan : accept = false; break;
                        case device_type_wlan_mon :   accept = false; break;
                        case device_type_eth :        accept = true;  break;
                        case device_type_cloud_eth :  accept = false; break;
                        default :                     oops   = true;  break;
                    }
                    break;

                    case PRISM_MSG :
                    switch (device_list[dev_index].device_type) {
                        case device_type_wlan :       accept = false; break;
                        case device_type_cloud_wlan : accept = false; break;
                        case device_type_wlan_mon :   accept = true;  break;
                        case device_type_eth :        accept = false; break;
                        case device_type_cloud_eth :  accept = false; break;
                        default :                     oops   = true;  break;
                    }
                    break;

                    default:  oops = true;
                    break;
                }

                if (oops) {
                    ddprintf("oops;  device %s, message type %x\n",
                            device_type_string(device_list[dev_index].
                                    device_type),
                            msg_type);
                    continue;
                }

                if (!accept) {
                    continue;
                }
                }

                /* if cloud_interface is true, we are getting 0x2983
                 * ('CLOUD_MSG') messages
                 * on the other interface, so ignore them if we get them
                 * from this interface.
                 */
                if (db[47].d
                    && is_298x_msg
                    && device_list[dev_index].device_type == device_type_eth
                    && message->eth_header.h_proto == htons(CLOUD_MSG))
                {
                    continue;
                }

                if (db[47].d
                    && is_298x_msg
                    && device_list[dev_index].device_type == device_type_wlan
                    && msg_type != AD_HOC_BLOCK_MSG
                    && message->eth_header.h_proto == htons(CLOUD_MSG))
                {
                    continue;
                }

                /* assign "dev" to index of device_list entry describing
                 * who sent it.  if ad-hoc message, figure out who sent it.
                 */

                /* this is eth0:1 but in wds mode */
                if (device_list[dev_index].device_type == device_type_cloud_wds)
                {
                    for (dev = 0; dev < device_list_count; dev++) {
                        if (device_list[dev].device_type == device_type_wds
                            && mac_equal(msg_buffer->eth_header.h_source,
                                    device_list[dev].mac_address))
                        { break; }
                    }
                    if (dev == device_list_count) {
                        continue;
                    }

                } else if (ad_hoc_mode
                    && (device_list[dev_index].device_type == device_type_wlan
                    || device_list[dev_index].device_type
                        == device_type_cloud_wlan))
                {
                    for (dev = 0; dev < device_list_count; dev++) {
                        if (device_list[dev].device_type == device_type_ad_hoc
                            && mac_equal(msg_buffer->eth_header.h_source,
                                    device_list[dev].mac_address))
                        { break; }
                    }
                    if (dev == device_list_count) {
                        ddprintf("could not find valid ad-hoc device for "
                                "h_source ");
                        mac_dprint(eprintf, stderr,
                                msg_buffer->eth_header.h_source);
                        continue;
                    }

                } else if (ad_hoc_mode && device_list[dev_index].device_type
                        == device_type_cloud_eth)
                {
                    for (dev = 0; dev < device_list_count; dev++) {
                        if (device_list[dev].device_type == device_type_eth) {
                            break;
                        }
                    }
                    if (dev == device_list_count) {
                        continue;
                        // ddprintf("could not find valid eth device.\n");
                        // dev = dev_index;
                    }

                } else {
                    dev = dev_index;
                }

                /* if debugging dev:1 packet accounting.. */
                if (db[48].d && device_list[dev_index].device_type
                    != device_type_wlan_mon)
                {
                    ddprintf("got message; dev %d, dev_index %d", dev,
                            dev_index);

                    fn_print_message(eprintf, stderr, (byte *) message, result);

                    if (is_298x_msg) {
                        ddprintf("; message seq %d, type %x",
                                message->sequence_num,
                                message->eth_header.h_proto);
                    }

                    ddprintf("\n");

                    if (is_298x_msg
                        && message->eth_header.h_proto
                        == htons(WRAPPED_CLIENT_MSG))
                    {
                        ddprintf("message body:\n");
                        fn_print_message(eprintf, stderr,
                                (byte *) msg_body,
                                result - wrapper_len);
                    }
                }

                /* debug print the message if not is_298x_msg message */
                if (db[43].d) {
                    if (device_list[dev_index].device_type
                            != device_type_wlan_mon
                        && !is_298x_msg)
                    {
                        ddprintf("recvfrom got non-cloud input from "
                                "dev_index %d, dev %d\n", dev_index, dev);
                        print_devices();

                        fn_print_message(eprintf, stderr,
                                (byte *) msg_body,
                                result);
                    }
                }

                /* debug print the message if is_298x_msg message */
                if (db[42].d) {
                    // DEBUG_SPARSE_PRINT(
                    if (is_298x_msg
                        /*&& message->eth_header.h_proto == htons(CLOUD_MSG)*/)
                    {
                        ddprintf("recvfrom got cloud input from "
                                "dev_index %d, dev %d\n",
                                dev_index, dev);
                        print_devices();

                        fn_print_message(eprintf, stderr,
                                (unsigned char *) message, result);
                    }
                    // )
                }

                if (is_298x_msg &&
                    (message->eth_header.h_proto == htons(CLOUD_MSG)
                    || message->eth_header.h_proto
                        == htons(WRAPPED_CLIENT_MSG)))
                {
                    if (db[48].d) { ddprintf("to sequence_check 1..\n"); }
                    sequence_check(message, dev, dev_index);
                }

                /* if this was a k-for-n message and not the last one,
                 * save it and hope for the rest of it eventually.
                 */
                if (is_298x_msg) {
                    if (!update_k_for_n_state(message, &result, dev)) {
                        continue;
                    }
                }

                /* if this is a message from the prism0 device and it
                 * is not a beacon message from a cloud box, ignore it.
                 * this test is probably not needed because of the switch above.
                 */
                if (!is_298x_msg
                    && have_mon_device && device_list[dev_index].fd == prism_fd)
                {
                    bool_t good_prism_msg =
                            wrt_util_beacon_message((byte *) msg_body, result);

                    if (db[45].d) {
                        ddprintf("prism message (%s):\n",
                                good_prism_msg ? "accepted" : "rejected");
                        fn_print_message(eprintf, stderr,
                                (byte *) msg_body, result);
                    }

                    if (!good_prism_msg) { continue; }
                }

                /* is this input from the client wireless interface?
                 * if so and debugging of that is on, debug print message.
                 */
                if (db[14].d && !ad_hoc_mode && is_wlan(&device_list[dev])) {
                    ddprintf("recvfrom eth2 %x; dev %d, fd, %d\n",
                            ntohs(message->eth_header.h_proto),
                            dev, device_list[dev].fd);
                    fn_print_message(eprintf, stderr,
                            (unsigned char *) message, result);
                }

                /* is this an ll_shell_ftp request? */
                if (is_298x_msg
                    && message->eth_header.h_proto == htons(LL_SHELL_MSG)
                    && do_ll_shell
                    && (mac_equal(message->eth_header.h_dest,
                        my_eth_mac_address)
                    || mac_equal(message->eth_header.h_dest,
                        my_wlan_mac_address)
                    ))
                {
                    stdout_print_cmd = true;
                    ddprintf("going to com_util_process_message..\n");

                    if (device_list[dev_index].device_type == device_type_eth) {
                        com_util_init(device_list[dev_index].fd,
                                device_list[dev_index].if_index,
                                use_pipes ? &device_list[dev_index].out_pio : 0,
                                my_eth_mac_address, com_util_mac_address);

                    } else if (device_list[dev_index].device_type
                        == device_type_wlan)
                    {
                        com_util_init(device_list[dev_index].fd,
                                device_list[dev_index].if_index,
                                use_pipes ? &device_list[dev_index].out_pio : 0,
                                my_wlan_mac_address, com_util_mac_address);
                    }

                    com_util_process_message((byte *) message);

                    stdout_print_cmd = false;
                }

                /* are we supposed to ignore "normal" (i.e., non-ll_shell_ftp)
                 * inputs from the eth device?
                 */
                if (is_eth(&device_list[dev_index]) && db[20].d) {
                    continue;
                }

                /* does this look like a beacon message from another cloud box?
                 */
                if (msg_type == PRISM_MSG && do_wrt_beacon)
                {
                    if (db[14].d && is_wlan(&device_list[dev])) {
                        ddprintf("recvfrom eth2 0x41\n");
                        fn_print_message(eprintf, stderr,
                                (byte *) message, result);
                    }

                    wrt_util_process_message((byte *) msg_body,
                            result - wrapper_len);

                    continue;
                }

                /* does this look like an eth_beacon message?  */
                if (is_298x_msg
                    && message->eth_header.h_proto == htons(ETH_BCN_MSG)
                    && do_eth_beacon && !db[20].d)
                {
                    eth_util_process_message((byte *) message);

                    continue;
                }

                /* does this look like a cloud message from another box? */
                if (is_298x_msg && message->eth_header.h_proto
                    == htons(CLOUD_MSG))
                {
                    io_stat[device_list[dev].stat_index].cloud_recv++;

                    process_cloud_message(message, dev);

                    continue;
                }

                forward_packet = false;

                if (is_298x_msg
                    && message->eth_header.h_proto == htons(WRAPPED_CLIENT_MSG))
                {
                    forward_packet = true;

                } else if (msg_type == OTHER_MSG) {

                    if (db[50].d
                        && ignore_ad_hoc_bcast(msg_body, result - wrapper_len))
                    {
                        forward_packet = false;
                    } else {
                        forward_packet = true;
                        message->eth_header.h_proto = htons(WRAPPED_CLIENT_MSG);
                    }
                }

                if (forward_packet) {
                    /* it's not a cloud message; we have a client message.
                     * send it along within the cloud and out the client
                     * interfaces (eth and wireless client)
                     */
                    if (db[1].d) {
                        DEBUG_SPARSE_PRINT(
                            ddprintf("got input from ");
                            print_device(eprintf, stderr, &device_list[dev]);
                            ddprintf("is_298x_msg:  %d\n", (int) is_298x_msg);

                            fn_print_message(eprintf, stderr,
                                    (unsigned char *) message, result);
                        )
                    }
                    if (db[14].d && is_wlan(&device_list[dev])) {
                        ddprintf("recvfrom eth2 do bcast_forward_message\n");
                    }

                    io_stat[device_list[dev].stat_index].noncloud_recv++;

                    if (result > max_packet_len) {
                        max_packet_len = result;
                    }

                    if (message_ok(dev, result)) {
                        bcast_forward_message(message, result, dev,
                                msg_type == OTHER_MSG);
                    }
                }
            }

        } else {
            if (db[19].d) {
                ddprintf("input is not available; "
                        "got_interrupt[send_stp, lockable_timeout]:  %d %d\n",
                        got_interrupt[send_stp],
                        got_interrupt[lockable_timeout]);
            }
        }

        done :

        eth_print_cmd = false;
        temp_print_cmd = false;
        com_util_close_temp_file(temp_log_fname, &temp_log_file);

        if (!fake_interrupt
            && (got_interrupt[send_stp] || got_interrupt[lockable_timeout]))
        {
            got_interrupt[send_stp] = 0;
            got_interrupt[lockable_timeout] = 0;
            post_repeated_cloud_maint();

            /* update the file used by status_lights. */
            update_cloud_status();

            if (db[31].d || db[38].d) {
                build_stp_list();
            }
        }

        if (got_interrupt[ping_neighbors]) {
            got_interrupt[ping_neighbors] = 0;
            do_ping_neighbors();
        }

        if (got_interrupt[disable_print_cloud]) {
            got_interrupt[disable_print_cloud] = 0;
            db[38].d = 0;
            db[30].d = 0;
        }

        if (got_interrupt[print_cloud]
            || (db[38].d && times[print_cloud].tv_sec == -1))
        {
            got_interrupt[print_cloud] = 0;
            do_print_cloud();
        }

        if (got_interrupt[wifi_scan] && db[62].d) {
            got_interrupt[wifi_scan] = 0;
            scan_timer();
        }

        #ifdef WRT54G
            pcritical_section_exit();
        #else
            critical_section_exit();
        #endif
    }
} /* main */
